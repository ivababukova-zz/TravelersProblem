\documentclass{mprop}
\usepackage{graphicx}
\usepackage{amsthm}
\theoremstyle{definition}
\usepackage{mathtools}
\usepackage[numbers]{natbib}
\usepackage{thmtools}
\usepackage[usenames, dvipsnames]{color}
\usepackage{algorithm}
\usepackage{algpseudocode}
\usepackage{hyperref}
\usepackage{caption}
\usepackage{subcaption}
\usepackage{amsfonts}

\newtheorem{example}{Example}
\newtheorem{theorem}{Theorem}

\declaretheoremstyle[headfont=\bfseries]{solution}
\declaretheoremstyle[headfont=\normalfont]{normalhead}
\declaretheorem[style=normalhead, numbered=no]{question}
\declaretheorem[style=normalhead, numbered=no]{instance}
\declaretheorem[style=solution, numbered=no]{solution}

\def\Item$#1${\item[] $\displaystyle#1$
   \hfill\refstepcounter{equation}(\theequation)}

% alternative font if you prefer
\usepackage{times}

% for alternative page numbering use the following package
% and see documentation for commands
%\usepackage{fancyheadings}


% other potentially useful packages
%\uspackage{amssymb,amsmath}
%\usepackage{url}
%\usepackage{fancyvrb}
%\usepackage[final]{pdfpages}

\begin{document}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\title{The Traveller's Problem}
\author{Iva Stefanova Babukova}
\date{18 December 2016}
\maketitle
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\tableofcontents
\educationalconsent
\newpage
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Introduction}\label{intro}

In this work we present the Traveller's Problem (TP), a computational task whose extensions and variations are often encountered by travellers around the world. The task is concerned with creating a valid travel schedule, using airplanes as a means of transportation and in accordance with certain constraints specified by the traveller.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Problem Formulation}

Each instance of TP consists of:

\begin{enumerate}
\item A set of airports $A = \{ A_{0},...,A_{n} \}$ for $n > 0$. Each airport $A_{i}$ $\in$ $A$ represents a location the traveller can begin their commute in, visit as a desired destination, or connect in on the way to their destination.

\item The trip starts and ends at the same airport $A_{0}$, which is referred to as the \textit{home point}.

\item The total travel time $T$, within which the traveller must have visited all destinations and returned to the home point. The first day is day 0.
 
\item A set of flights $F = \{ f_{0},...,f_{m} \}$. Each flight $f_{j}$ has:
\begin{itemize}
\item departure airport $A^{d}_{j}$,
\item arrival airport $A^{a}_{j}$,
\item date $t_{j}$,
\item duration $\Delta_{j}$,
\item cost $c_{j}$,
\end{itemize} 
for some non-negative integer $j$ less than or equal to $n$.
The date $t_{j}$ is a positive rational number less than or equal to $T$ that shows at which day $f_{j}$ leaves its departure airport. The duration $\Delta{j}$ is a positive fraction that shows the amount of time that takes for flight $f_{j}$ to go from $A^{d}_{j}$ to $A^{a}_{j}$. The cost $c_{j}$ is a positive number that denotes the number of units of some currency $\epsilon$ that the traveller pays in order to be able to board flight $f_{j}$.

\item Each airport $A_{i}$ has a \textit{connection time} $C_{A_{i}}$, that is the time that takes to switch from any selected flight $f_{p}$ with $A^{a}_{p} = A_{i}$ to any selected flight $f_{q}$ with $A^{d}_{q} = A_{i}$, where $f_{q}$ is immediately after $f_{p}$ in a solution.

\item A set of \textit{destinations} $D = \{ D_{1},...,D_{l} \}$, $D \subseteq A$, $l \leq n$.
\end{enumerate}

A solution to any instance of TP is a sequence $s$ of $k$ valid flights, $ \langle f_{i_{1}}, f_{i_{2}},...,f_{i_{k}} \rangle \, \subseteq F$, \textcolor{red}{also called a \textit{trip}}. We say that $s$ is valid if the flights in $s$ have the following properties:

\begin{enumerate}
\Item $A^{d}_{i_{1}} = A^{a}_{i_{k}} = A_{0}$
\Item $ A^{a}_{i_{j}} = A^{d}_{i_{j+1}},  \quad 0 < j < k  \quad j$
\Item $ t_{i_{j}} + \Delta_{i_{j}} + C_{r} \leq t_{i_{j+1}}, \quad 0 < j \leq k, \quad \textrm{where } r = A^{d}_{i_{j+1}}$
% david mentioned about possibly adding this as a hard constraint?
\Item $t_{i_{k}} + \Delta_{i_{k}} \leq T$
\Item $ \forall D_{p} \in D, \textrm{ } \exists \textrm{ } f_{i_{j}} \in s \textrm{, such that } A^{a}_{i_{j}} = D_{p} $
\end{enumerate}

\textcolor{red}{In this work, we refer to these properties as \textit{trip properties}}. Note that a valid sequence of flights may contain one or more flights to and from airports that are not destinations. Such airports are called \textit{connections}.

% these statements are only really meaningful when you relate TP to TSP and also to VRP.
% \textcolor{red}{Also note that the current problem formulation accepts asymmetric flight costs, i.e. one might have two flights $f_{i}$ and $f_{j}$ such that $A^{d}_{i} = A^{a}_{j}$ and $A^{a}_{i} = A^{d}_{j}$. That does not imply that $c_{i} = c_{j}$. Moreover, the problem formulation does not restrict the flight cost to depend on the flight duration. Consequently, this implies that TP is \textit{asymmetric} and in general the flight cost need not satisfy the \textit{triangle inequality}.}

The \textit{optimization} version of TP (TPO) asks for an \textit{optimal} solution \textcolor{red}{$s$} which minimizes the total sum of the prices of the flights in $s$, denoted by $c(s)$.

The \textit{decision} version of TP (TPD) asks whether there exists a valid sequence of flights $s$, such that $c(s)$ is less than or equal to some given integer $B$. The solution of this problem is a `yes' or `no' answer.

There exist a variety of additional constraints and extensions that can be added to TP. Our problem formulation has only presented the hard constraints which every valid solution to a TP instance must satisfy. In real-world problems, travellers may have additional preferences (soft constraints) and requirements (hard constraints) with regards to their travel. These are discussed in the next two sections.

\subsection{Hard Constraints}
This section presents some additional constraints that might be imposed on a TP instance. If any of them is required, then a solution that does not satisfy the requirement is considered as invalid.

\begin{itemize}
\item Travellers may wish to spend a certain amount of days at a given destination, specified by both upper and lower bounds. The days may additionally be constrained to be consecutive or not.

\item Travellers may require to spend a given date at a given destination, for example due to an event occurring on that date in this destination.

\item Travellers may require not to fly through a given airport more than once.
\end{itemize}

\subsection{Soft Constraints}
It may be desirable to search for a solution that satisfies some of the following requirements:

\begin{itemize}
\item Travellers may wish to spend a certain amount $\delta_{i}$ of days in each destination $D_{i}$, where $\delta_{i}$ may be specified as a lower or an upper bound.

\item Travellers may wish to avoid taking connection flights. In such requirement, we wish to maximise the number of flights to and from destinations.

\item Travellers may want to spend as little time on flying as possible. In such case, we wish to find a solution that minimises the sum of the durations of all flights.
\end{itemize}

%% mention the problem with lexicographic optimisation and multi-objective opimisation
Note that we may have an instance for which all soft constraints can not be satisfied simultaneously. In such case, the traveller may be required to rank his requirements in an order of preference. The instance becomes a lexicographic optimisation problem, where we first optimise the highest ranked objective, and subject to this we optimise the second ranked objective and so on.
If all requirements are equally important for the traveller, we have to solve a multiobjective optimisation problem, where the objectives are all constraints required by the traveller. Each of the objectives is given a weight of importance. The problem is then to optimize the objective function, composed by the constraints, each of them multiplied by its weight. Multiobjective and lexicographic optimisation problems are discussed later in this work. %% TODO: discuss them

Note that most of the aforementioned constraints can be viewed as either hard or soft, depending on the user requirements. It is therefore suggested that any attempt at an investigation of TP assumes as an additional non-functional requirement that any proposed model to solve TP is flexible and can be easily extended by adding, removing and modifying the aforementioned constraints.

\section{Worked Examples}
We present an example instance of TP and comment on some of its solutions.

\begin{example}
\label{example1}
A traveller wishes to visit 4 airports from a set of 7 airports available to travel to and from: 

Glasgow (G), Berlin (B), Milan (M), Amsterdam (A), Paris (P), Frankfurt (F), London (L).

Airport G is the home point, F and L are connections, and B, M, A and P are the destinations. The travel time of the traveller is 15 days. All available flights are listed on Table \ref{table:flights} \textcolor{red}{ and the example is shown pictorially on Figure \ref{fig:map}}. For simplicity, the duration of each flight is assumed to be 1 day. This means that if the traveller gets a flight at date $x$, they will reach the arrival airport at day $x+1$.

\begin{figure}
\centering
\includegraphics[height=6cm, width=7.5cm]{images/map.png}
\caption{\textcolor{red}{ All airports in Example 1. The links between each two airports are available at certain dates and vary in price, as indicated in Table \ref{table:flights}.}}
\label{fig:map}
\end{figure}

\begin{table}
\centering
\renewcommand{\arraystretch}{1.4}% Spread rows out...
\begin{tabular}{|l|l|c|c|c|c|c|}
\hline
& \textbf{Flight No} & \textbf{Departs} & \textbf{Arrives} & \textbf{Date} & \textbf{Price} \\
\hline
1 & GA1 & G & A & \date{1} & 74 \\
\hline
2 & GF1 & G & F & \date{1} & 86 \\
\hline
3 & FB2 & F & B & \date{2} & 156 \\
\hline
4 & GL3 & G & L & \date{3} & 25 \\
\hline
5 & MF3 & M & F & \date{3} & 78 \\
\hline
6 & BP4 & B & P & \date{4} & 67 \\
\hline
7 & AP4 & A & P & \date{4} & 58 \\
\hline
8 & PM6 & P & M & \date{6} & 71 \\
\hline
9 & FM8 & F & M & \date{8} & 234 \\
\hline
10 & MF9 & M & F & \date{9} & 39 \\
\hline
11 & FA10 & F & A & \date{10} & 220 \\
\hline
12 & FB11 & F & B & \date{11} & 122 \\
\hline
13 & FM12 & F & M & \date{12} & 250 \\
\hline
14 & PL12 & P & L & \date{12} & 45 \\
\hline
15 & BG13 & B & G & \date{13} & 335 \\
\hline
16 & BL13 & B & L & \date{13} & 102 \\
\hline
17 & AG13 & A & G & \date{13} & 90 \\
\hline
18 & LG14 & L & G & \date{14} & 24 \\
\hline
\end{tabular}
\caption{List of flights with departure and arrival airports, flight date and price.}
\label{table:flights}
\end{table}
\end{example}

\begin{solution}
A valid solution of the TP instance in the example above is the trip $s$, where the each flight is represented by its flight number, specified in the first column of Table \ref{table:flights}:

$$ s = \langle GA1, AP4, PM6, MF9, FB11, BG13\rangle $$

The total flights cost $c(s)$ is 699.

A valid solution with lower cost is the following trip:

$$ s^{\prime} = \langle GA1, AP4, PM6, MF9, FB11, BL13, LG14\rangle $$

Here $c(s^{\prime})$ is 483 and hence $s$ is not optimal.
\end{solution}

\begin{example}
\label{example2}
Given the same problem instance as in Example \ref{example1}, suppose that the traveller has booked a ticket for a concert in B on day 3. The traveller requires to attend the concert.
\end{example}

\begin{solution}
In such case, neither $s$, nor $s^{\prime}$ from Example \ref{example1} are solutions, because both of them assign the traveller to be at a different location (airport A) at day 3. The following sequence is a solution:

$$ s^{\prime\prime} = \langle GF1, FB2, BP4, PM6, MF9, FA10, AG13\rangle $$

The total cost $c(s^{\prime\prime})$ is equal to 729, which is more expensive than $s$ and $s^{\prime}$.
\end{solution}

\section{List of Problems}
\label{npcompleteproblems}

This Section gives a list of known problems, referred to in this work when proving the NP-hardness of TP (Section \ref{npcompleteproof}) and when reviewing the existing work (Section \ref{sec:existingwork}). The problems, marked with an asterisk ($\ast$) next to their title, are known to be NP-complete \citep{thebible}.

\begin{enumerate}

% \item \textbf{Vehicle-Routing Problem \textsuperscript{*} (VRP)}
% \begin{instance}
% .
% \end{instance}
% \begin{question}
% .
% \end{question}

\item \textbf{Travelling Salesman Problem \textsuperscript{*} (TSP) \footnote{Note that TSP is a special case of VRP when only one vehicle is allowed.}}
\begin{instance}
Set $A$ of $n$ cities, distance $d(A_{i}, A_{j})$ between each pair of cities $A_{i}$, $A_{j}$ $\in$ $A$, positive integer $B$.
\end{instance}

\begin{question}
Is there a tour of $A$ having length $B$ or less, i.e., a permutation of cities $\gamma = \langle A_{\pi(1)}, A_{\pi(2)},...,A_{\pi(n)} \rangle $ of $A$ such that the total travel distance $L_{\gamma}$:
$$L_{\gamma} = \bigg( \sum_{i=1}^{n-1} d(A_{\pi(i)}, A_{\pi(i+1)}) \bigg) + d(A_{\pi(n)}, A_{\pi(1)}) \leq B \quad \textrm{?}$$
\end{question}

\item \textbf{Travelling Salesman Problem Under the Triangle Inequality\textsuperscript{*} (TSP-$\Delta$) \footnote{Note that this problem is a special case of TSP.}}
\begin{instance}
Set $A$ of $n$ cities, distance $d(A_{i}, A_{j})$ between each pair of cities $A_{i}$, $A_{j}$ $\in$ $A$ that satisfies the triangle inequality, positive integer $B$.
\end{instance}

\begin{question}
Is there a tour of $A$ having length $B$ or less, i.e., a permutation of cities $\gamma = \langle A_{\pi(1)}, A_{\pi(2)},...,A_{\pi(n)} \rangle $ of $A$ such that the total travel distance $L_{\gamma}$:
$$L_{\gamma} = \bigg( \sum_{i=1}^{n-1} d(A_{\pi(i)}, A_{\pi(i+1)}) \bigg) + d(A_{\pi(n)}, A_{\pi(1)}) \leq B \quad \textrm{?}$$
\end{question}

\item \textbf{Time-Constrained TSP\textsuperscript{*} (TCTSP) \footnote{Note that this problem is a generalisation of TSP.}}

\begin{instance}
Set $A$ of $n$ cities, distance $d(A_{i}, A_{j})$ between each pair of cities $A_{i}$, $A_{j}$ $\in$ $A$, positive integer $B$, lower and upper bounds $l_{i}$ and $u_{i}$ respectively for each city $A_{i}$ that specify its time window.
\end{instance}

\begin{question}
Is there a permutation of cities $\gamma = \langle A_{\pi(1)}, A_{\pi(2)},...,A_{\pi(n)} \rangle$ of $A$, such that each city $A_{\pi_{j}}$ is visited at time $t_{j}$, where $l_{j} \leq t_{j} \leq u_{j}$, $t_{j} < t_{j+1}$ for ($1 \leq j \leq n-1 $) and 
$$L_{\gamma} = \bigg( \sum_{i=1}^{n-1} d(A_{\pi(i)}, A_{\pi(i+1)}) \bigg) + d(A_{\pi(n)}, A_{\pi(1)}) \leq B \quad \textrm{?}$$

\end{question}

\item \textbf{Job-Shop Scheduling Problem\textsuperscript{*} (JSSP)}
\begin{instance}
A set $R$ of resources and a set $N$ of jobs. Each job $J \in N$ consists of a sequence of operations $O_{J}$, a ready time $rt_{J}$ and a deadline $dt_{J}$. Each operation $i$ has processing time $p_{i}$ and required resource $r_{i}$.
\end{instance}

\begin{question}
Is there a sequence $S = \{st_{i} : i \in J, \forall J \in N\}$ of starting times for every operation, such that every job meets its deadline and each resource is used by no more than one job at the same time?
\end{question}

\item \textbf{The Assignment Problem (AP)}

\begin{instance}
Set $A$ and set $B$ with equal size, cost $c(a,b)$ of matching $a \in A$ to $b \in B$.
\end{instance}

\begin{question}
Find a bijection $f: A \gets B$ such that $\sum_{a\in A} c(a,f(a))$ is minimised.
\end{question}
% \item \textbf{Job-Shop Scheduling Problem (JSSP)}
% \item \textbf{Longest Path Problem}
\end{enumerate}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Complexity of TP}
We state a theorem about the complexity of TP and prove it.
\begin{theorem}
TPD is NP-complete.
\end{theorem}

\begin{proof}
\label{npcompleteproof}
This proof first shows the membership of TPD in the NP class of problems. Second, we prove the NP-hardness of TP by constructing a polynomial-time reduction from a known NP-complete problem $\Pi$ to TPD, where $\Pi$ is chosen to be TSP, defined in Section \ref{npcompleteproblems}. Its NP-hardness follows by a reduction from the Hamiltonian Cycle problem. The proof is presented by \citet{thebible}.

Given an instance of TPD and $s$, which is a sequence of flights from $F$, we can write an algorithm that checks in polynomial time whether $s$ is a solution. To accept or reject validity, the algorithm only needs to traverse $s$ and check that it satisfies all required properties. Therefore, TP is in NP.

Let $\pi$ be an instance of TSP. Let $\pi^{\prime}$ be an instance of TPD with the following properties:
\begin{itemize}
\item The set of airports in $\pi^{\prime}$ is identical to the set of cities in $\pi$ and it is similarly denoted as $A$ (a city in $\pi$ is called an airport in $\pi^{\prime}$). Airport $A_{1}$ is the home point.
\item Each airport in $A$ is also a destination.
\item The connection time $C_{A_{i}}$ for each airport $A_{i}$ is equal to 0.
\item $T$ is equal to $n$.
\item Let $C$ be the Cartesian product of the airports in $A$ with itself, that is $C = A \times A$ = \{($A_{i}, A_{j}$) : $A_{i}$ $\in$ $A$, $A_{j}$ $\in$ $A$, $i \neq j$\}. Then $F$ is a set of flights, such that for every ($A_{i}, A_{j}$) $\in$ $C$, there exists a flight $f_{k}$ in $F$, such that $A^{d}_{k} = A_{i}$ and $A^{a}_{k} = A_{j}$ for every date $0 \leq t < T$.
\item For every $f_{k}$ $\in$ $F$, $c_{k}$ is equal to $d(A^{d}_{k}, A^{a}_{k})$ in $\pi$. Therefore, the flight costs also satisfy the triangle inequality.
\item For every $f_{k}$ $\in$ $F$, $\Delta_{k}$ = 1.
\item $B$ is the upper bound on the allowed total cost.
\end{itemize}

%% TSP solution => also TP solution

Suppose that $\gamma$ = $ \langle A_{i_{1}}, A_{i_{2}},...,A_{i_{n}} \rangle $ is a solution to $\pi$, where $\langle i_{1},...,i_{n} \rangle$ is a permutation of $\langle 1,...,n \rangle $ and the total travel distance $L_{\gamma} \leq B$. Without loss of generality, assume that $i_{1} = 1$. In $\pi^{\prime}$, $\gamma$ is equivalent to the order of visited airports by some sequence of flights $s$ = $ \langle f_{j_{1}}, f_{j_{2}},...f_{j_{n}} \rangle $, such that for each $p$  $(1 \leq p \leq n)$ there exists $q$ $(1 \leq q \leq n)$ such that $A^{d}_{j_{q}} = A_{i_{p}}$ and $A^{a}_{j_{q}} = A_{i_{p+1}}$, where subscripts are taken modulo $n$. Therefore, $s$ satisfies property (1) of a valid solution. For each $q$ $(1 \leq q \leq n)$, $A^{a}_{j_{q}} = A^{d}_{j_{q+1}}$ and $t_{j_{q}} = q - 1$.  We know that such flights exist in $F$ by the construction of the set $F$.

From the construction of $s$, it follows that property (2) also holds. Properties (3) and (4) also hold, since we have chosen flights from $F$ such that for every $f_{j_{q}}$ $\in$ $s$, $t_{j_{q}} = q - 1$ ($(1 \leq q \leq n)$). Property (5) is satisfied, since all airports in $A$ are destinations.

Since the cost of every flight in $F$ is equal to the distance between the two cities in $\pi$ that correspond to its departure and arrival airport, it follows that $c(s) = L_{\gamma} \leq B$.

The sequence $s$ satisfies all requirements for a valid solution to $\pi^{\prime}$. Therefore, a solution of $\pi$ is also a solution to $\pi^{\prime}$.

Conversely, suppose that $s = \langle f_{j_{1}},...,f_{j_{k}} \rangle $ is a solution to $\pi^{\prime}$, where the flights in $s$ visit destinations in the sequence $\gamma^{\prime}$ = $\langle A_{i_{1}}, A_{i_{2}},...,A_{i_{m}} \rangle$. We will prove that $\gamma^{\prime}$ is a solution of $\pi$.

By construction of $\pi^{\prime}$, all airports in $A$ are also destinations. Therefore, $\gamma^{\prime}$ contains all cities in $A$, that is $m \geq n$. Suppose that $m > n$ and an arbitrary airport $A_{p}$ $(1 \leq p < n)$ is included more than once in $\gamma^{\prime}$. Then $s$ must contain more than one flight with arrival airport equal to $A_{p}$. 
The duration of each flight in $\pi^{\prime}$ is one day. Therefore, for every $q$ $(1 \leq q < n - 1)$, $t_{j_{q+1}} = q$. Since the traveller has only $n$ days of total travel time, and $s$ is restricted to contain exactly $n$ flights, that is $k = n$. The only way to visit $n$ distinct destinations, given $n$ flights is that all flights in $s$ have unique arrival airports. Assuming that $A_{p}$ is visited more than once means that there is more than one flight with arrival airport equal to $A_{p}$, which is a contradiction. Therefore, $m = n$ and each airport in $A$ is visited exactly once.

From the properties of $s$ it follows that $A^{d}_{j_{1}} = A^{a}_{j_{n}} = A_{1}$. Therefore, $\gamma^{\prime}$ is a cycle of size $n$. We know that $c(s) \leq B$. We assigned a cost of each flight $f_{k}$ in $F$ to be equal to $d(A^{d}_{k}, A^{a}_{k})$ in $\pi$. Therefore, the total travel distance $L_{\gamma^{\prime}} = c(s)$ which is less than or equal to $B$.

According to the specifications of $\pi$, $\gamma^{\prime}$ is a solution to $\pi$. Therefore, a solution to $\pi^{\prime}$ is also a solution to $\pi$.

The transformation from a TSP instance to an instance of TPD can be done in polynomial time. For each of the $n$($n$-1)/2 distances d($A_{i}$, $A_{j}$) that must be specified in $\pi$, it is sufficient to check that the same cost is assigned to the flights from $A_{i}$ to $A_{j}$ for all dates.

Therefore, TP is in NP and the decision version of TSP can be reduced to TPD in polynomial time, from which it follows that TPD is NP-complete.

\end{proof}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Background Survey}

%present an overview of relevant previous work including articles, books, and existing software products. Critically evaluate the strengths and weaknesses of the previous work.

\label{sec:existingwork}
We present some existing approaches to dealing with NP-hard problems, namely branch and bound (Section \ref{branchandbound}), constraint programming (Section \ref{cp}) and integer programming (Section \ref{ip}). The way each of these methods tackles NP-hardness is illustrated with a specific problem as an example, defined in Section \ref{npcompleteproblems}.


\subsection{Linear and Integer Programming}
\label{ip}

Linear Programming (LP) is a way to solve problems by modeling their requirements as a system of linear inequalities and equations and subject to them finding an optimal solution to the problem, expressed as a function that has to be either minimised or maximised. This function is called the \textit{objective function}.

The field of LP is well-studied \citep{Kantorovich60,DantzigLp63} and it has many applications in the industry for resource optimisation \citep{Jacovkis89,Garvin57}. However, \citet{Dantzig60} shows that there are many important optimisation problems that can not be modeled as a linear program, because their variables can take only integer values. Such problems can be modeled with the tools of integer programming (IP). Integer programming (IP) is an extension of linear programming (LP). The difference between LP and IP is that in the IP model variables are restricted to take only integer values.

The rest of this section presents different methods to solve problems with the tools offered by IP and comments on their performance by using TSP as an example problem.

\subsubsection{Integer Programming Formulation of TSP}
% \texorpdfstring{TSP-$\Delta$}{Lg}}
\label{sec:iptspformulation}

\citet{Dantzig54} formulate TSP as the following IP problem. Let $x(i,j)$ be a variable that denotes whether city $j$ succeeds city $i$ in a TSP tour. The value of $x(i,j)$ is equal to 1 if this is true, or 0 if it is false. If $x(i,j)$ is 1, then $i$ is called the \textit{outgoing} city and $j$ - the \textit{incoming} city. The objective function of TSP is to minimise the total length of the tour, that is:

\begin{equation}
\label{eq:objfunc}
\textrm{min } \sum_{i\in A}\sum_{j\in A} d(i,j)x(i,j)
\end{equation}

In each TSP tour every city is visited once. Moreover, each city has to be incoming and outgoing exactly once. Therefore, the value of $x(i,j)$ for every $i$ will be 1 for only one $j$ and 0 for the rest. This can be enforced with the following constraint:

\begin{equation}
\label{eq:one}
\begin{split}
  \sum_{j \in A} x(i,j) = 1, \qquad i \in A,\\
  \sum_{i \in A} x(i,j) = 1, \qquad j \in A,
\end{split}
\end{equation}

Constraint (\ref{eq:one}) ensures that each city in $A$ is picked exactly once as an incoming and an outgoing city. However, it allows for the existence of one or more cycles of $n_{1} < n$ cities, called \textit{subtours}. For instance, consider Figure \ref{fig:tour} and Figure \ref{fig:subtours}. Both of them satisfy constraint (\ref{eq:one}). However, Figure \ref{fig:subtours} does not represent a valid tour, because it contains two subtours, each of size 3. To tackle this problem, \citet{Dantzig54} introduce the \textit{subtour elimination} constraint, that is:

\begin{equation}
\label{eq:subtourElimination}
\sum \{x(i,j) : (i,j) \in (S \times \bar{S}) \cup (\bar{S} \times S)\} \geq 2, \quad \forall \, \emptyset \subset S \subset A, \textrm{ where } \bar{S} = A \setminus S
\end{equation}

Here, $S$ is a subset of A and $\bar{S}$ is the set of all cities that are in $A$ and not in $S$. Constraint (\ref{eq:subtourElimination}) enforces that at least two cities in $S$ are connected with cities from $\bar{S}$. We give Figure \ref{fig:tour} and Figure \ref{fig:subtours} as an example. Let $S = \{A_{1},A_{2},A_{3}\}$, then $\bar{S} = \{A_{4},A_{5},A_{6}\}$. Constraint (\ref{eq:subtourElimination}), would detect the tour on Figure \ref{fig:subtours} as invalid, as there is no city in $S$ that is connected to a city in $\bar{S}$. Figure \ref{fig:tour} will be accepted, since $A_{1}$ and $A_{3}$ are connected with $A_{6}$ and $A_{4}$ respectively.

\begin{figure}
\centering
\begin{minipage}{.5\textwidth}
  \centering
  \includegraphics[width=4cm, height=4cm]{images/valid.png}
  \caption{A valid TSP tour}
  \label{fig:tour}
\end{minipage}%
\begin{minipage}{.5\textwidth}
  \centering
  \includegraphics[width=4cm, height=4cm]{images/invalid.png}
  \caption{Two subtours of size 3}
  \label{fig:subtours}
\end{minipage}
\end{figure}

The formulation of the general TSP problem is given by the objective function (\ref{eq:objfunc}), which has to be minimised, subject to constraints (\ref{eq:one}) and (\ref{eq:subtourElimination}).

\subsubsection{The Assignment Problem Relaxation}
%The Assignment Problem (AP), formulated in Section \ref{npcompleteproblems}, can be represented with the tools of linear programming and it can be solved in at most $\mathcal{O}(n^{3})$ steps \citep{Kuhn55}. 

The assignment problem (AP) relaxation consists of removing the subtour elimination constraint from the TSP IP model and minimising the objective function (\ref{eq:objfunc}) only subject to constraint (\ref{eq:one}). This is well known and extensively used relaxation \cite{Little63,Eastman58,Bellmore71,Baker83,Laporte86}. In this section we explain how this method helps in solving NP-hard problems, using TSP as an example.

\textcolor{red}{
Let $\pi^{\star}$ be the resulting problem after performing AP relaxation on some instance $\pi$ of TSP. 
The feasible solutions in $\pi$ correspond to travelling salesman tours and we let $opt(\pi)$ denote an optimal solution. The feasible solutions in $\pi^{\star}$ correspond to perfect matchings and we let $opt(\pi^{\star})$ correspond to a perfect matching of minimum weight.
}

Problem $\pi^{\star}$ can be modelled as a bipartite graph $G(V,E)$, as shown on Figure \ref{fig:tspbipartite}. The vertex set of $G$ is $V=O \cup I$, where $O = o_{1},..,o_{n}$ and $I = i_{1},...,i_{n}$ \textcolor{red}{both correspond to $A$.} The set of edges is $E = \{(o_{p}, i_{q}) \,|\, a_{p},a_{q} \in A,\, p \neq q \}$. Each edge $e = (o_{p}, i_{q}) \in E$ has weight $w_{e}$ equal to $d(a_{p},a_{q})$ and it represents a link from $a_{p}$ to $a_{q}$.

Figure \ref{fig:validAP} and Figure \ref{fig:invalidAP} are both examples of a perfect matching, where Figure \ref{fig:validAP} has $(o_{1} \rightarrow i_{2})$, $(o_{2} \rightarrow i_{3})$, $(o_{3} \rightarrow i_{4})$, $(o_{4} \rightarrow i_{5})$, $(o_{5} \rightarrow i_{6})$ and $(o_{6} \rightarrow i_{1})$.
Every $sol(\pi^{\star})$ can be translated to a path through the cities in $\pi$ as follows: for every matched pair of vertices $(o_{p} \rightarrow i_{q})$ in $sol(\pi^{\star})$, it is sufficient to choose city $a_{q}$ as the next visited city after $a_{p}$ in $\pi$. \textcolor{red}{For example, the matching in Figure \ref{fig:validAP} gives the tour shown in Figure \ref{fig:tour} and the matching in Figure \ref{fig:invalidAP} is equivalent to the subtours in Figure \ref{fig:subtours}.
}

\begin{figure}
\centering
\begin{minipage}{.5\textwidth}
\centering
 \includegraphics[width=3cm, height=4cm]{images/validAP.png}
 \caption{AP solution equivalent to Figure \ref{fig:tour}}
 \label{fig:validAP}
\end{minipage}%
\begin{minipage}{.5\textwidth}
\centering
 \includegraphics[width=3cm, height=4cm]{images/invalidAP.png}
 \caption{AP solution equivalent to Figure \ref{fig:subtours}}
 \label{fig:invalidAP}
\end{minipage}
\end{figure}

\begin{figure}
\centering
\includegraphics[width = 3cm, height = 4cm]{images/tspbipartite.png}
\caption{Problem $\pi^{\star}$ represented as a graph $G(V,E)$}
\label{fig:tspbipartite}
\end{figure}

\textcolor{red}{
Note that 
%$sol(\pi^{\star})$ need not map to $sol(\pi)$, as suggested from the previous example. However, every $sol(\pi)$ can be translated to some $sol(\pi^{\star})$. 
a feasible solution in $\pi$ maps to a feasible solution in $\pi^{\star}$, but the converse need not to true in general, as the example in Figure \ref{fig:invalidAP} shows.
}

Let $opt(\pi^{\star})$ have total edge weight equal to $\alpha$. Suppose that $opt(\pi^{\star})$ does not map to a tour in $\pi$. Therefore, $opt(\pi)$ must have length at least $\alpha$. Conversely, suppose that $opt(\pi^{\star})$ can be mapped to $opt(\pi)$. Therefore, the length of $opt(\pi)$ is equal to $\alpha$. Hence, the length of $opt(\pi)$ is greater than or equal to the value of $opt(\pi^{\star})$.
In the existing work, this property is used to derive a lower bound on the cost of $opt(\pi)$ \citep{Little63,Dantzig54,Baker83}. This approach is frequently combined with a branch and bound technique \citep{tspbible}, which is discussed in Section \ref{branchandbound}.

%\textcolor{blue}{The relation between TSP and AP is explained very nicely by \citet{Flood56}}

% \textcolor{red}{
% Another method for solving TSP with the AP relaxation is as follows. First, solve $\pi^{\prime}$. Then, check whether the solution contains any subtours and if yes, eliminate them. Iterate until a feasible enough solution is reached.}

% By dropping constraint (\ref{eq:subtourElimination}), the solution of $P_{AP}$ can be either a tour, or a collection of subtours. Hence, every tour of $P$ is a solution to AP, but not all solutions of AP are tours \citep{Bellmore71}. This allows for using the cost of the optimal solution of AP as a lower bound for the most optimal solution of $P$. In \cite{tspbible} it is showed with an experiment that both in theory and in practice the most optimal solution to AP is very likely to be a strong bound on $P$. The AP can be solved in at most $\mathcal{O}(n^{3})$ steps \citep{Kuhn55,Christofides75}. The ``bound'' procedure, that is called for every problem $P_{ij}$ in Algorithm \ref{alg:branchandbound}, computes AP$_{ij}$. It is shown in \cite{tspbible} that computing AP$_{ij}$ for each problem $P_{ij}$ in at most $\mathcal{O}(n^{2})$ steps by the Hungarian method \citep{Kuhn55}, provided that the algorithm is started from the optimal solution of the parent problem $P_{i}$.

\citet{Dantzig54} solve the constructed TSP model using a novel method for that time, which they call the ``cutting-plane method''. We point the interested reader back to \citep{Dantzig54} and \citep{Dantzig59}, where in the latter the cutting-plane method is explained in more detail using a 10 city TSP instance as an example.

%\textcolor{blue}{What is the complexity of the AP? Why is this not the best lower bound for TSP? Write about the min-weight spanning tree bound, briefly and say that it is better than this one. Compare their complexities.}

\subsection{Constraint Programming}
\label{cp}
\textcolor{red}{
Constraint Programming (CP) is widely used method for solving optimisation problems \citep{Caseau97, Manlove07, Mcdonald02}. Given an instance $\pi$ of an optimisation problem, we first model it as a constraint satisfaction problem (CSP) $CSP(\pi)$. Problem $CSP(\pi)$ consists of a set of decision variables $V$, each with a set of possible values, called its \textit{domain}, and a set of rules, called \textit{constraints} concerning the assignment of values to variables. A solution to $\pi$ is an assignment of each variable in $V$ to a value in its domain, such that all constraints are satisfied. The program that searches for a solution $CSP(\pi)$ is called a \textit{solver}.}

Whenever the domain $dom_{v}$ of a variable $v$ is empty in some temporal assignment of variables, we say that we have a \textit{domain wipeout} and this variables assignment is regarded as invalid. The \textit{degree} of $v$ is the number of constraints that involve $v$ and at least one other unassigned variable.

% todo: add citations
\textcolor{red}{
Finding a solution to $CSP(\pi)$ involves a search through the assignments of the variables in $CSP(\pi)$. Finding an optimal solution or proving that no solution exists requires iterating over the entire search space in the worst case. There are multiple techniques to speed up the search, such as identifying and discarding poor temporal variable assignments from further investigation, implementing intelligent search methods, or adding \textit{heuristics} for variable and value assignments. We discuss some heuristics that could be applicable to TP in the next section.}

\subsubsection{Heuristics}
% todo: is the thing in blue true?
Heuristics are rules concerning the ordering of variables or assignments of values, used to ``guide'' the search that aim to limit the total explored search space. Previous work has shown that heuristics can have a significant effect on search effort \citep{Haralick80:a, Gent96}. However, they are not guaranteed to always work. Heuristics are applicable for the cases when the solution is not required to be an optimum and when the particular problem instance has no solutions. In the latter, heuristics can help to prove early in the search that a given partial solution leads to a domain wipeout. This section presents some of the most well-known heuristics and gives an example of two successful heuristics that are tailored specifically for the Job-Shop Scheduling Problem (JSSP), defined in Section \ref{npcompleteproblems}.

Research effort is spent on understanding heuristics and the properties that improve their effectiveness. \citet{Christopher03} develop a framework for analysing the effectiveness of  heuristics. \citet{Hooker95} prove that heuristics that create simpler subproblems are successful in general, and heuristics that create subproblems that are more likely to be satisfiable are usually ``bad''. \citet{Haralick80} propose the intuition that ``to succeed, try first where you are most likely to fail'', known as the \textit{fail-first principle}. It suggests that the variable to be assigned next should be the one which is most-likely to lead to a domain wipeout of some variable.

\textcolor{red}{
The fail-first principle is a base for the development of various heuristics. For instance, \citet{Golomb65} propose a heuristic \texttt{dom} that chooses next assigned variable to be the one with the smallest number of values remaining in its domain. \citet{Brelaz79} introduce a new generalisation of \texttt{dom}, denoted as \texttt{dom+deg}, which chooses the variable with the smallest number of values remaining in its domain, breaking ties on highest variable degree. Another generalisation of \texttt{dom} is \texttt{dom/deg}, which divides the domain size of a variable by the degree by its degree and chooses the variable that gives minimal value \citep{Bessiere96}. All of these are \textit{variable ordering} heuristics, because they determine the next explored variable during search.}

%\textcolor{blue}{few words about how good fail-first principle is}

%\textcolor{blue}{Value-ordering heuristics examples}

% todo: explain why TP is similar to JSSP, why TP is similar to TSP. Maybe put the explanation in the problems definition.
\subsubsection*{The Slack-Based Heuristics}
\textcolor{red}{
The slack-based heuristics are introduced by \citet{Smith93} for the JSSP, defined in Section \ref{npcompleteproblems}. They help in determining how to sequence a given pair of operations in an instance of JSSP, modelled as CSP. There are various ways to model JSSP as CSP, which is a significant area of research on its own. We refer the interested reader to \citet[Chapter~22]{cpbible} for an extensive discussion.
This section explains the main principles of the slack-based heuristics, comments on their performance and discusses our hypothesis that it could be applicable to TP (which is the main reason why they are discussed here).
}

% todo: the following paragraph does not make sense for somebody who has not read the original paper
\textcolor{red}{
Let $\pi_{J}$ be an instance of the JSSP and let $CSP(\pi_{J})$ be constructed using some CSP model for JSSP, which includes a variable $o(i,j)$ that determines the ordering of any pair of operations $i$ and $j$ in $\pi_{J}$. The value of $o(i,j)$ is 1 when $i$ is scheduled before $j$, or 0 otherwise. There are four possible restrictions for the values of $o(i,j)$, imposed by the constraints in $CSP(\pi_{J})$: 
\begin{enumerate}
\item $o(i,j)$ can only be 0, i.e. $i$ is before $j$ in the current variable assignment.
\item $o(i,j)$ can only be 1, i.e. $j$ is before $i$ in the current variable assignment.
\item $o(i,j)$ can be neither 0 nor 1, i.e. there is a domain wipeout.
\item $o(i,j)$ can be either 0 or 1, i.e. there is no restriction on the ordering of $i$ and $j$.
\end{enumerate}
The slack-based heuristics are only applicable for case 4 and thus we skip to discuss the first three possibilities.}

%The slack-based heuristics developed by Smith and Cheng (1993) choose ordering variables according to the width of task start windows and the overlap between windows.
\textcolor{red}{
For every $o(i,j)$ that can be either 0 or 1, \citet{Smith93} compute $slack(i, j)$, which is the temporal time remaining after ordering $i$ before $j$ and similarly $slack(j, i)$, as shown in Figure \ref{fig:slack}. If process $i$ is sequenced before process $j$, then $slack(i, j)$ indicates the time window within which $j$ has to be completed.
Two different heuristics for the sequencing of $i$ and $j$, based on the size of the time window are introduced: \textit{min-slack} and \textit{max-slack}.}

\begin{figure}
\centering
\includegraphics[height=7cm, width=6cm]{images/slack.png}
\caption{The values of $slack(i, j)$ (the length of the bottom pink line) and $slack(j, i)$ (the length of the top pink line)}
\label{fig:slack}
\end{figure}

\textcolor{red}{
Min-slack ordering selects an ordering of $i$ and $j$ that gives minimum time flexibility for the tasks, that is $min\{slack(i, j), slack(j, i)\}$. For instance, min-slack heuristics would assign $o(i,j) = 1$ for the example in Figure \ref{fig:slack}.}

\textcolor{red}{
Max-slack heuristic orders the operations, such that there is greatest time flexibility for the tasks, that is $max\{slack(i, j), slack(j, i)\}$. In the example in Figure \ref{fig:slack}, max-slack would assign $o(i,j) = 1$.}

\textcolor{red}{We relate the idea behind min-slack to the principles of the \texttt{dom} heuristic. If the starting times of $i$ and $j$ are variables, then the assignment of $o(i,j)$ based on min-slack would decrease the domain of the starting time of the second scheduled process. As opposed to min-slack, max-slack would maximize the number of possible starting times. We recognise that this idea can be traced back to the work of \citet{Geelen92} which proposes a principle that each variable should be assigned the least constraining value in its domain.}

\textcolor{red}{
\citet{Smith93} compare the slack-based heuristics with two solution procedures over the same suite of benchmark problems and report on obtaining ``comparable results at very low computational expense''. In \citet[p.~105]{cpbible}, slack-based heuristics are described as ``effective''. However, \citet{Crawford94} argue that their effectiveness is mainly due to their problem representation method.}

%\textcolor{blue}{Why do we think that these heuristics are applicable to TP? Write that this is relevant to TP when we have some time between arriving in some city and leaving the city. There are various options: leave the city earlier, or at the latest moment, etc.}

% \subsection{Multiobjective Optimisation}

% In Section XXX we discussed TP instances that require solving more than one objective function, subject to the same constraints, where the objectives may be in conflict, i.e. there is no solution that satisfies all of them simultaneously. In such case, a weighting factor is assigned to each objective and the problem is to optimise the new objective function, obtained by summing all objectives, with each of them multiplied by its weighting factor. In this Section, we briefly discuss existing approaches to multiobjective optimisation.

% \subsubsection{Multiobjective Genetic Algorithms}

% \subsubsection{The Pareto Optimum}

\subsection{Branch and Bound Algorithms}
\label{branchandbound}

%\textcolor{red}{ The origins of the branch and bound technique date back to the work by \citet{Dantzig54}, where an instance with 49 cities is solved and proved as optimal. The term ``branch and bound'' itself was introduced by \citet{Little63}.} 

%\textcolor{red}{The branch and bound procedure repeatedly breaks up the set of feasible solutions into successively smaller subsets and calculates a \textit{bound} on the objective function value for each subset. The bounds are obtained by performing \textit{relaxation}, i.e. replacing the problem over a given subset with an easier (\textit{relaxed}) problem, such that the solution value of the latter bounds that of the former. Bounds are used to discard certain subsets from further consideration.}

% \textcolor{red}{
% Branch and bound procedure can be represented as a rooted tree whose root node corresponds to the original problem and the leafs of the tree form the set of all candidate solutions. The successor nodes of each non-leaf node $i$ correspond to the subproblems, defined by the branching rule.}

% \textcolor{red}{
% Algorithm \ref{alg:branchandbound} does not tell much about the ``choose'', ``branch'' and ``bound'' procedures. This is because there are many variations of their implementations. We discuss some of them in the following parts of this section.}

% This relaxation is based on expressing the integer programming version of an optimisation problem $P$ as an assignment problem (AP) after dropping one or more constraints from $P$.
% The AP relaxation is successfully used for solving TSP \cite{Little63,Eastman58,Bellmore71,tspbible,Baker83} and for the Vehicle Routing Problem (VRP) \citep{Laporte86,vrpbible}. We explain the principles of this relaxation using TSP as a use case.

% In this formulation, one can remove constraint (\ref{eq:subtourElimination}) to obtain an instance of AP with the same cost function as $P$ \citep{Little63,Eastman58,Bellmore71}.

% By dropping constraint (\ref{eq:subtourElimination}), the solution of $P_{AP}$ can be either a tour, or a collection of subtours. Hence, every tour of $P$ is a solution to AP, but not all solutions of AP are tours \citep{Bellmore71}. This allows for using the cost of the optimal solution of AP as a lower bound for the most optimal solution of $P$. In \cite{tspbible} it is showed with an experiment that both in theory and in practice the most optimal solution to AP is very likely to be a strong bound on $P$. The AP can be solved in at most $\mathcal{O}(n^{3})$ steps \citep{Kuhn55,Christofides75}. The ``bound'' procedure, that is called for every problem $P_{ij}$ in Algorithm \ref{alg:branchandbound}, computes AP$_{ij}$. It is shown in \cite{tspbible} that computing AP$_{ij}$ for each problem $P_{ij}$ in at most $\mathcal{O}(n^{2})$ steps by the Hungarian method \citep{Kuhn55}, provided that the algorithm is started from the optimal solution of the parent problem $P_{i}$.

%Performance

% The AP relaxation is reported to perform differently, depending on the type of the problem \citep{tspbible,Bellmore71}. In particular, its performance highly depends on whether the problem has symmetric or asymmetric cost matrix. In the case with TSP, symmetric cost matrix refers to the property that the distance $d(i,j)$ from $i$ to $j$ is equal to $d(j,i)$. TSP with symmetric cost matrix is called Symmetric TSP (STSP) and Asymmetric TSP (ATSP) otherwise.

% Experiments with ATSP instances have shown that the AP relaxation provides an excellent lower bound \citep{tspbible}. 

% Until the late 1980s, the most effective exact approaches for the vehicle routing problem were mainly branch and bound algorithms \citep{vrpbible}.

%todo: mention dynamic programming and approx algorithms as another way to solve hard problems and cite most important papers. Write little about multiobjective optimsation

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Proposed Approach}

\textcolor{red}{
We model TP as Integer and Constraint Programming problems. The Constraint Programming (CP) approach is explained in Section \ref{subsec:tpcp} and the Integer Programming (IP) model is presented in Section \ref{subsec:tpip}.}
%Why is this approach chosen? ...

\subsection{CP Model}
\label{subsec:tpcp}
\textcolor{red}{
Let $m = |F|$. We introduce an array $\mathcal{S}$ of size $m+1$ (indexed $0,1,...,m$) that represents the TP tour and a variable $z$ with domain $dom_{z} = \{1,...,m\}$ to denote the number of flights in the trip. If $\mathcal{S}[i] = j$, then flight $f_{j} \in F$ is the $(i+1)^{th}$ flight in the tour. }To denote the end of the tour, we set $\mathcal{S}[z] = 0$. All subsequent variables in $\mathcal{S}$ will then have to be 0. Each variable $v$ in $\mathcal{S}$ is either 0, if no flight is taken at that step, or it is equal to some flight number, that is $dom_{v} = \{0,...,m\}$.

TP can then be formulated as the problem of minimising the objective function:

\begin{equation}
\label{eq:TPwithCPobj}
\sum^{m-1}_{i = 0} c_{\mathcal{S}[i]}
\end{equation}

subject to constraints (10-16).

\begin{itemize}
\color{red}
\Item
$\exists z > 0 \textrm{ such that } \mathcal{S}[i] > 0 \textrm{ for } (0 \leq i \leq z-1) \wedge \mathcal{S}[i] = 0 \textrm{ for } (z \leq i \leq m)$
\Item
$\textrm{allDiff}(\mathcal{S}[0],...,\mathcal{S}[z-1])$
\end{itemize}

Constraint (10) restricts that once the end of the trip is reached at some position $z$, no flights are further added to $\mathcal{S}$. Constraint (11) enforces that every flight is taken only once, using an all-different constraint \citep{Hoeve01}.

The trip properties are added to the model as follows:

\begin{itemize}
% property 1:
\Item
$dom_{\mathcal{S}[0]} = \{j \in \{1,...,m\} : A^{d}_{j} = A_{0}\}$
\item[]
$dom_{\mathcal{S}[z-1]} = \{j \in \{1,...,m\} : A^{a}_{j} = A_{0}\}$
% property 2:
\Item
$dom_{\mathcal{S}[i]} = \{0, j \in \{1,...,m\} : A^{d}_{j} = A^{a}_{p}, \, p = \mathcal{S}[i-1]\}, \quad (1 \leq i < z)$
\end{itemize}
\begin{itemize}
\color{red}
% property 3:
\Item
$t_{p} + \Delta_{p} + C_{r} \leq t_{q}, \textrm{ where } p = \mathcal{S}[j], q = \mathcal{S}[j+1], r = A^{a}_{q}, \, (0 \leq j < z)$
% property 4:
\Item
$t_{q} + \Delta_{q} \leq T, \quad \textrm{ where } q = \mathcal{S}[z-1]$
\end{itemize}
\begin{itemize}
% property 5:
\Item
$\forall A_{k} \in D, \, |\{i: (0 \leq i < z) \wedge A^{a}_{\mathcal{S}[i]} = A_{k} \}| > 0 $
\end{itemize}

Constraint (12) is equivalent to trip property (1). It restricts the domains of the first and the $(z-1)^{th}$ variable in $\mathcal{S}$ to contain only flights that depart from/arrive at the home point. Trip property (2) is enforced by constraint (13). The domain of each variable in $\mathcal{S}$ is set to include only flights that depart from the arrival airport of the previous flight. Constraints (14) and (15) correspond to trip properties (3) and (4) respectively. Constraint (16) restricts that the number of the flights that arrive at every destination in the trip is positive, and thus enforces trip property (5).

\subsection{IP Model}
\label{subsec:tpip}

Most of the constraints for the TP CP model need modification in order to be applicable to an IP model. In particular, IP does not allow for ``if-then'', ``all-different'' and other constraints that are not integer linear inequalities. The model described in this section is a modification of the TP CP model, described in the previous section, that gives constraints in the form of integer linear inequalities, which we also refer to as\textcolor{red}{ \textit{ constraints}.}

Let $m = |F|$. We introduce a variable $x_{i,j}$ for every $i \in \{0,...,m-1\}$ and  $j \in \{1,...,m\}$, such that $x_{i,j} = 1$ if $(i+1)^{th}$ flight is $f_{j}$ or 0 otherwise. This variable is somewhat similar to $\mathcal{S}$, used for the CP model, where $\mathcal{S}[i] = p$ is equivalent to $x_{i,p} = 1$. \textcolor{red}{In addition, we introduce a variable $x_{m,0} = 1$, where flight $f_{0}$ is a ``special'' flight with duration $\Delta_{j} = 0$, date $t_{j} = T$, departure and arrival airports $A^{d}_{j} = A^{a}_{j} = A_{0}$ and cost $c_{j} = 0$, added to $F$.} 


From trip property (2) it follows that there must exist some $z < m$, $x_{z,j} = 1$, for which $j \neq 0$ and $A^{a}_{j} = A_{0}$. Thus, constraint (21) indirectly enforces trip property (1). The objective function of TP is to minimise:

\begin{equation}
\color{red}
\label{eq:TPwithIPobj}
\sum^{m-1}_{i} \sum^{m}_{j} c_{j} x_{i,j}
\end{equation}

\textcolor{red}{subject to constraints (18-23).}

First, we restrict that only one flight is taken at each step $i$ with constraint (18). Constraint (19) is equivalent to the all-different constraint (11): it enforces every flight to be taken at most once.

\begin{itemize}
\color{red}
\Item
$\forall i \, (0 \leq i < m), \quad \sum^{m}_{j = 1}x_{i,j} = 1 $
\Item
$\forall j \, (0 \leq j \leq m), \quad \sum^{m-1}_{i = 0}x_{i,j} = 1 $
\end{itemize}

\textcolor{red}{
Our method to express the properties of a trip as integer linear inequalities is as follows. Assume that flight $z-1$ is the final flight returning to $A_{0}$, where $1 \leq z \leq m$. We add $m-z+1$ many $f_{0}$ flights, so that the variables $x_{z,0},...,x_{m,0}$ are all equal to 1. We do not add connection time when connecting from $A_{0}$ to $A_{0}$ as part of these flights.}

\textcolor{red}{Constraints (20) and (21) enforce trip property (1). The first flight is restricted to depart from the home point and the last flight must arrive at the home point.}

\begin{itemize}
% property 1:
\Item
$\sum_{j \in S_{1}} x_{0,j} = 1, \quad \textrm{where } S_{1} = \{j \in \{1,...,m\} : A^{d}_{j} = A_{0}\}$
\Item
$x_{m,0} = 1$
\end{itemize}

Property (2) is enforced by defining two sets of flights $S_{1}$ and $S_{2}$, such that all flights in $S_{2}$ depart from the arrival airport of $S_{1}$. Constraint (22) restricts that every flight always departs from the arrival airport of the previous taken flight.

\begin{itemize}
\color{red}
% property 2:
\Item
$\sum_{j \in S_{1}} x_{i-1,j} = \sum_{j^{\prime} \in S_{2}} x_{i,j^{\prime}}, \quad \forall i \, (1 \leq i \leq m) \wedge \forall y \in A, \textrm{ where}$
\item[]
$S_{1} = \{j \in \{0,...,m\} : A^{a}_{j} = y\} \textrm{ and } S_{2} = \{j^{\prime} \in \{0,...,m\} : A^{d}_{j^{\prime}} = y\}$
\end{itemize}

\textcolor{red}{
Trip properties (3) and (4) are represented by constraint (23), which enforces that every flight $f_{j}$ cannot depart until the previous flight $f_{j^{\prime}}$ has arrived, adding connection time, if needed. The connection time $C^{\prime}_{r}$ is equal to the connection time of the arrival airport, unless the current flight is $f_{0}$.
}

\begin{itemize}
\color{red}
% property 3 and 4:
\Item
$x_{i+1,j} + \sum_{j^{\prime} \in F^{\prime}} x_{i,j^{\prime}} \leq 1, \quad \forall i \, (0 \leq i < m) \textrm{ and }  \forall j \, (0 \leq j \leq m)$
\item[]
$\textrm{where } F^{\prime} = \{j^{\prime} : f_{j^{\prime}} \in F \wedge t_{j^{\prime}} + \Delta_{j^{\prime}} + C^{\prime}_{r} > t_{j} \} \textrm{ and}$
\item[]
$C^{\prime}_{r} =   \begin{cases}
0, \quad \textrm{ if } j=0 \\
C_{A^{a}_{j^{\prime}}}, \quad \textrm{ otherwise}
\end{cases}
$
\end{itemize}

% property 5:
Trip property (5) is enforced by restricting that all destination airports must be visited by at least one flight:

\begin{itemize}
\Item
$\forall A_{k} \in D, \, \sum_{i=0}^{m-1} \sum_{j \in F_{k}} x_{i,j} \geq 1, \quad \textrm{ where } F_{k}= \{j : f_{j}\in F \wedge A^{a}_{j} = A_{k}\} $
\end{itemize}

\subsection{Modelling soft and hard constraints}

\subsection{Choice of CP and IP solvers}

%Gurobi

\subsection{Experimental Datasets}

This section describes the instances that will be used for the empirical analysis of our algorithms for TP.

\subsubsection{Skyscanner Flights API}
Skyscanner is a metasearch engine that enables people to find and compare flights, hotels and cars for hire in terms of price, date and duration.
They offer us access to their in-house flights API. Given a departure and an arrival airport and a date, it returns a set of flights with these attributes.

The Skyscanner flights API will be used during the empirical analysis to construct TP instances with varying size and properties. Testing our algorithms on these instances will show the effectiveness of our algorithms on real-world problems.

\subsection*{Generating instances from the Skyscanner data}

\subsubsection{Randomly Generated TP instances}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Work Plan}

Implement the IP and CP model for TP. (mid December-mid January)

Implement support for the soft and hard constraints. (mid January - mid February)

Generate TP instances for empirical evaluation. (mid February - 1st March)

Run the algorithms on the test data and analyse results. (March-April)

Submission deadline: 21 April 2017, 12PM 

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% it is fine to change the bibliography style if you want
\bibliographystyle{plainnat}
\bibliography{mprop}
\end{document}
